# 数组
1. 数组是一种**线性表**数据结构。它用一组**连续的内存空间**，来存储一组**具有相同类型的数据**
    - 线性表就是数据排成一条线一样的结构。每个线性表上的数据最多只有前和后两个方向，数组、链表、队列、栈等都是线性表
    - 连续的内存空间和相同的数据类型：既造就了数组**随机访问**的优点，也导致了数组在删除、插入元素时的低效
    - 数组支持随机访问，随机访问的时间复杂度是O(1);数组适合查找，即使是已排好序的数组，使用二分查找，时间复杂度也是为O(log(n)); 注意使用正确的表述
2. 数组插入元素
    - 如果数组是有序的，在指定位置插入一个新元素时，最好情况时间复杂度为O(1)，最坏情况时间复杂度为O(n)，平均时间复杂度为O(n)
    - 如果数组是无序的，可以直接把第K位的数据移到数组元素的最后，把新元素直接放入到第K个位置，时间复杂度为O(1)
3. 数组删除元素
    - 在指定位置删除一个新元素时，最好情况时间复杂度为O(1)，最坏情况时间复杂度为O(n)，平均时间复杂度为O(n)
    - 在某些特殊场景下，不一定非要追求数组中数据的连续性。可以先记录下已经删除的数据，当数组没有更多空间存储数据时，再出发执行一次真正的删除操作，这样能有效降低删除操作带来的数据搬移
    - 类似于JVM标记清除垃圾回收算法
4. ArrayList
    - 与数组比较的优势：可以**将很多数组操作的细节封装起来**，比如说数组插入，删除数据时需要搬移其他数据的操作；ArrayList支持**动态扩容**
    - ArrayList在扩容时需要搬移大量数据，是比较耗时的。所以如果事先能确定需要存储的数据大小，最好在创建ArrayList时事先指定数据大小
5. 数组和容器的选择
    - java ArrayList不支持存储基本类型，需要封装为Integer，Long这样的封装类型，而Autoboxing，boxing则会带来一定的性能消耗，如果特别关注性能，可以考虑使用数组
    - 如果数据的大小已知，且对数据的操作非常简单，可以直接使用数组
    - 当要表示多维数据时，使用数组会比较直观
    - **业务开发时，直接使用容器就足够了**；非常底层的开发，数组成为首选
6. 数组下标从0开始编号的原因
    - 从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移offset”。如果用a表示数组的首地址，a[0]就是偏移为0的地址，a[k]就是偏移k个type_size的位置
    - *原因1* 从0开始编号，cpu在计算a[k]的内存地址时使用以下公式
    ```
    a[k]_address = base_address + k * type_size
    ```
    如果从1开始编号，计算a[k]的内存地址就变为
    ```
    a[k]_address = base_address + (k-1) * type_size
    ``` 
    对于CPU而言就多了一次减法运算
    - *原因2* 历史原因，沿用C语言用0开始计数数组下标 


